import {
  createPopper,
  init_lib
} from "./chunk-IKWR32CH.js";
import {
  require_warning
} from "./chunk-ZGDF32YP.js";
import "./chunk-C2QERBZB.js";
import {
  require_react_dom
} from "./chunk-GSZ7ISAW.js";
import {
  require_react_fast_compare
} from "./chunk-6M4F7MGH.js";
import {
  require_jsx_runtime
} from "./chunk-VTQ2JCVL.js";
import {
  require_react
} from "./chunk-ZGRSIX2Q.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/detect-it/dist/detect-it.esm.js
var detect_it_esm_exports = {};
__export(detect_it_esm_exports, {
  deviceType: () => deviceType,
  primaryInput: () => primaryInput,
  supportsPassiveEvents: () => supportsPassiveEvents,
  supportsPointerEvents: () => supportsPointerEvents,
  supportsTouchEvents: () => supportsTouchEvents
});
var w, matchMedia, passiveOptionAccessed, options, noop, supportsPassiveEvents, supportsPointerEvents, onTouchStartInWindow, touchEventInWindow, supportsTouchEvents, hasTouch, userAgent, isIPad, hasCoarsePrimaryPointer, hasAnyHoverOrAnyFinePointer, deviceType, primaryInput;
var init_detect_it_esm = __esm({
  "node_modules/detect-it/dist/detect-it.esm.js"() {
    w = typeof window !== "undefined" ? window : { screen: {}, navigator: {} };
    matchMedia = (w.matchMedia || function() {
      return { matches: false };
    }).bind(w);
    passiveOptionAccessed = false;
    options = {
      get passive() {
        return passiveOptionAccessed = true;
      }
    };
    noop = function() {
    };
    w.addEventListener && w.addEventListener("p", noop, options);
    w.removeEventListener && w.removeEventListener("p", noop, false);
    supportsPassiveEvents = passiveOptionAccessed;
    supportsPointerEvents = "PointerEvent" in w;
    onTouchStartInWindow = "ontouchstart" in w;
    touchEventInWindow = "TouchEvent" in w;
    supportsTouchEvents = onTouchStartInWindow || touchEventInWindow && matchMedia("(any-pointer: coarse)").matches;
    hasTouch = (w.navigator.maxTouchPoints || 0) > 0 || supportsTouchEvents;
    userAgent = w.navigator.userAgent || "";
    isIPad = matchMedia("(pointer: coarse)").matches && // both iPad and iPhone can "request desktop site", which sets the userAgent to Macintosh
    // so need to check both userAgents to determine if it is an iOS device
    // and screen size to separate iPad from iPhone
    /iPad|Macintosh/.test(userAgent) && Math.min(w.screen.width || 0, w.screen.height || 0) >= 768;
    hasCoarsePrimaryPointer = (matchMedia("(pointer: coarse)").matches || // if the pointer is not coarse and not fine then the browser doesn't support
    // interaction media queries (see https://caniuse.com/css-media-interaction)
    // so if it has onTouchStartInWindow assume it has a coarse primary pointer
    !matchMedia("(pointer: fine)").matches && onTouchStartInWindow) && // bug in firefox (as of v81) on hybrid windows devices where the interaction media queries
    // always indicate a touch only device (only has a coarse pointer that can't hover)
    // so assume that the primary pointer is not coarse for firefox windows
    !/Windows.*Firefox/.test(userAgent);
    hasAnyHoverOrAnyFinePointer = matchMedia("(any-pointer: fine)").matches || matchMedia("(any-hover: hover)").matches || // iPads might have an input device that can hover, so assume it has anyHover
    isIPad || // if no onTouchStartInWindow then the browser is indicating that it is not a touch only device
    // see above note for supportsTouchEvents
    !onTouchStartInWindow;
    deviceType = hasTouch && (hasAnyHoverOrAnyFinePointer || !hasCoarsePrimaryPointer) ? "hybrid" : hasTouch ? "touchOnly" : "mouseOnly";
    primaryInput = deviceType === "mouseOnly" ? "mouse" : deviceType === "touchOnly" ? "touch" : (
      // if the device is a hybrid, then if the primary pointer is coarse
      // assume the primaryInput is touch, otherwise assume it's mouse
      hasCoarsePrimaryPointer ? "touch" : "mouse"
    );
  }
});

// node_modules/react-popper/lib/esm/Manager.js
function Manager(_ref2) {
  var children = _ref2.children;
  var _React$useState = React.useState(null), referenceNode = _React$useState[0], setReferenceNode = _React$useState[1];
  var hasUnmounted = React.useRef(false);
  React.useEffect(function() {
    return function() {
      hasUnmounted.current = true;
    };
  }, []);
  var handleSetReferenceNode = React.useCallback(function(node) {
    if (!hasUnmounted.current) {
      setReferenceNode(node);
    }
  }, []);
  return React.createElement(ManagerReferenceNodeContext.Provider, {
    value: referenceNode
  }, React.createElement(ManagerReferenceNodeSetterContext.Provider, {
    value: handleSetReferenceNode
  }, children));
}
var React, ManagerReferenceNodeContext, ManagerReferenceNodeSetterContext;
var init_Manager = __esm({
  "node_modules/react-popper/lib/esm/Manager.js"() {
    React = __toESM(require_react());
    ManagerReferenceNodeContext = React.createContext();
    ManagerReferenceNodeSetterContext = React.createContext();
  }
});

// node_modules/react-popper/lib/esm/utils.js
var React2, unwrapArray, safeInvoke, setRef, fromEntries, useIsomorphicLayoutEffect;
var init_utils = __esm({
  "node_modules/react-popper/lib/esm/utils.js"() {
    React2 = __toESM(require_react());
    unwrapArray = function unwrapArray2(arg) {
      return Array.isArray(arg) ? arg[0] : arg;
    };
    safeInvoke = function safeInvoke2(fn) {
      if (typeof fn === "function") {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        return fn.apply(void 0, args);
      }
    };
    setRef = function setRef2(ref, node) {
      if (typeof ref === "function") {
        return safeInvoke(ref, node);
      } else if (ref != null) {
        ref.current = node;
      }
    };
    fromEntries = function fromEntries2(entries) {
      return entries.reduce(function(acc, _ref2) {
        var key = _ref2[0], value = _ref2[1];
        acc[key] = value;
        return acc;
      }, {});
    };
    useIsomorphicLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement ? React2.useLayoutEffect : React2.useEffect;
  }
});

// node_modules/react-popper/lib/esm/usePopper.js
var React3, ReactDOM, import_react_fast_compare, EMPTY_MODIFIERS, usePopper;
var init_usePopper = __esm({
  "node_modules/react-popper/lib/esm/usePopper.js"() {
    React3 = __toESM(require_react());
    ReactDOM = __toESM(require_react_dom());
    init_lib();
    import_react_fast_compare = __toESM(require_react_fast_compare());
    init_utils();
    EMPTY_MODIFIERS = [];
    usePopper = function usePopper2(referenceElement, popperElement, options2) {
      if (options2 === void 0) {
        options2 = {};
      }
      var prevOptions = React3.useRef(null);
      var optionsWithDefaults = {
        onFirstUpdate: options2.onFirstUpdate,
        placement: options2.placement || "bottom",
        strategy: options2.strategy || "absolute",
        modifiers: options2.modifiers || EMPTY_MODIFIERS
      };
      var _React$useState = React3.useState({
        styles: {
          popper: {
            position: optionsWithDefaults.strategy,
            left: "0",
            top: "0"
          },
          arrow: {
            position: "absolute"
          }
        },
        attributes: {}
      }), state = _React$useState[0], setState = _React$useState[1];
      var updateStateModifier = React3.useMemo(function() {
        return {
          name: "updateState",
          enabled: true,
          phase: "write",
          fn: function fn(_ref2) {
            var state2 = _ref2.state;
            var elements = Object.keys(state2.elements);
            ReactDOM.flushSync(function() {
              setState({
                styles: fromEntries(elements.map(function(element) {
                  return [element, state2.styles[element] || {}];
                })),
                attributes: fromEntries(elements.map(function(element) {
                  return [element, state2.attributes[element]];
                }))
              });
            });
          },
          requires: ["computeStyles"]
        };
      }, []);
      var popperOptions = React3.useMemo(function() {
        var newOptions = {
          onFirstUpdate: optionsWithDefaults.onFirstUpdate,
          placement: optionsWithDefaults.placement,
          strategy: optionsWithDefaults.strategy,
          modifiers: [].concat(optionsWithDefaults.modifiers, [updateStateModifier, {
            name: "applyStyles",
            enabled: false
          }])
        };
        if ((0, import_react_fast_compare.default)(prevOptions.current, newOptions)) {
          return prevOptions.current || newOptions;
        } else {
          prevOptions.current = newOptions;
          return newOptions;
        }
      }, [optionsWithDefaults.onFirstUpdate, optionsWithDefaults.placement, optionsWithDefaults.strategy, optionsWithDefaults.modifiers, updateStateModifier]);
      var popperInstanceRef = React3.useRef();
      useIsomorphicLayoutEffect(function() {
        if (popperInstanceRef.current) {
          popperInstanceRef.current.setOptions(popperOptions);
        }
      }, [popperOptions]);
      useIsomorphicLayoutEffect(function() {
        if (referenceElement == null || popperElement == null) {
          return;
        }
        var createPopper2 = options2.createPopper || createPopper;
        var popperInstance = createPopper2(referenceElement, popperElement, popperOptions);
        popperInstanceRef.current = popperInstance;
        return function() {
          popperInstance.destroy();
          popperInstanceRef.current = null;
        };
      }, [referenceElement, popperElement, options2.createPopper]);
      return {
        state: popperInstanceRef.current ? popperInstanceRef.current.state : null,
        styles: state.styles,
        attributes: state.attributes,
        update: popperInstanceRef.current ? popperInstanceRef.current.update : null,
        forceUpdate: popperInstanceRef.current ? popperInstanceRef.current.forceUpdate : null
      };
    };
  }
});

// node_modules/react-popper/lib/esm/Popper.js
function Popper(_ref2) {
  var _ref$placement = _ref2.placement, placement = _ref$placement === void 0 ? "bottom" : _ref$placement, _ref$strategy = _ref2.strategy, strategy = _ref$strategy === void 0 ? "absolute" : _ref$strategy, _ref$modifiers = _ref2.modifiers, modifiers = _ref$modifiers === void 0 ? EMPTY_MODIFIERS2 : _ref$modifiers, referenceElement = _ref2.referenceElement, onFirstUpdate = _ref2.onFirstUpdate, innerRef = _ref2.innerRef, children = _ref2.children;
  var referenceNode = React4.useContext(ManagerReferenceNodeContext);
  var _React$useState = React4.useState(null), popperElement = _React$useState[0], setPopperElement = _React$useState[1];
  var _React$useState2 = React4.useState(null), arrowElement = _React$useState2[0], setArrowElement = _React$useState2[1];
  React4.useEffect(function() {
    setRef(innerRef, popperElement);
  }, [innerRef, popperElement]);
  var options2 = React4.useMemo(function() {
    return {
      placement,
      strategy,
      onFirstUpdate,
      modifiers: [].concat(modifiers, [{
        name: "arrow",
        enabled: arrowElement != null,
        options: {
          element: arrowElement
        }
      }])
    };
  }, [placement, strategy, onFirstUpdate, modifiers, arrowElement]);
  var _usePopper = usePopper(referenceElement || referenceNode, popperElement, options2), state = _usePopper.state, styles = _usePopper.styles, forceUpdate = _usePopper.forceUpdate, update = _usePopper.update;
  var childrenProps = React4.useMemo(function() {
    return {
      ref: setPopperElement,
      style: styles.popper,
      placement: state ? state.placement : placement,
      hasPopperEscaped: state && state.modifiersData.hide ? state.modifiersData.hide.hasPopperEscaped : null,
      isReferenceHidden: state && state.modifiersData.hide ? state.modifiersData.hide.isReferenceHidden : null,
      arrowProps: {
        style: styles.arrow,
        ref: setArrowElement
      },
      forceUpdate: forceUpdate || NOOP,
      update: update || NOOP_PROMISE
    };
  }, [setPopperElement, setArrowElement, placement, state, styles, update, forceUpdate]);
  return unwrapArray(children)(childrenProps);
}
var React4, NOOP, NOOP_PROMISE, EMPTY_MODIFIERS2;
var init_Popper = __esm({
  "node_modules/react-popper/lib/esm/Popper.js"() {
    React4 = __toESM(require_react());
    init_Manager();
    init_utils();
    init_usePopper();
    NOOP = function NOOP2() {
      return void 0;
    };
    NOOP_PROMISE = function NOOP_PROMISE2() {
      return Promise.resolve(null);
    };
    EMPTY_MODIFIERS2 = [];
  }
});

// node_modules/react-popper/lib/esm/Reference.js
function Reference(_ref2) {
  var children = _ref2.children, innerRef = _ref2.innerRef;
  var setReferenceNode = React5.useContext(ManagerReferenceNodeSetterContext);
  var refHandler = React5.useCallback(function(node) {
    setRef(innerRef, node);
    safeInvoke(setReferenceNode, node);
  }, [innerRef, setReferenceNode]);
  React5.useEffect(function() {
    return function() {
      return setRef(innerRef, null);
    };
  }, []);
  React5.useEffect(function() {
    (0, import_warning.default)(Boolean(setReferenceNode), "`Reference` should not be used outside of a `Manager` component.");
  }, [setReferenceNode]);
  return unwrapArray(children)({
    ref: refHandler
  });
}
var React5, import_warning;
var init_Reference = __esm({
  "node_modules/react-popper/lib/esm/Reference.js"() {
    React5 = __toESM(require_react());
    import_warning = __toESM(require_warning());
    init_Manager();
    init_utils();
  }
});

// node_modules/react-popper/lib/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Manager: () => Manager,
  Popper: () => Popper,
  Reference: () => Reference,
  usePopper: () => usePopper
});
var init_esm = __esm({
  "node_modules/react-popper/lib/esm/index.js"() {
    init_Popper();
    init_Manager();
    init_Reference();
    init_usePopper();
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/clamp.js
var require_clamp = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/clamp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clamp = void 0;
    function clamp(value, min, max) {
      return min < max ? value < min ? min : value > max ? max : value : value < max ? max : value > min ? min : value;
    }
    exports.clamp = clamp;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/imageRatio.js
var require_imageRatio = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/imageRatio.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getContainerToImageRatio = exports.getLargeToSmallImageRatio = exports.getSmallToLargeImageRatio = void 0;
    function getSmallToLargeElementRatio(smallElement, largeElement) {
      return {
        x: smallElement.width ? largeElement.width / smallElement.width : 1,
        y: smallElement.height ? largeElement.height / smallElement.height : 1
      };
    }
    function getSmallToLargeImageRatio(smallImage, largeImage) {
      return getSmallToLargeElementRatio(smallImage, largeImage);
    }
    exports.getSmallToLargeImageRatio = getSmallToLargeImageRatio;
    function getLargeToSmallImageRatio(smallImage, largeImage) {
      return {
        x: smallImage.width ? smallImage.width / largeImage.width : 1,
        y: smallImage.height ? smallImage.height / largeImage.height : 1
      };
    }
    exports.getLargeToSmallImageRatio = getLargeToSmallImageRatio;
    function getContainerToImageRatio(container, image) {
      return getSmallToLargeElementRatio(container, {
        width: image.width - container.width,
        height: image.height - container.height
      });
    }
    exports.getContainerToImageRatio = getContainerToImageRatio;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/imageCoordinates.js
var require_imageCoordinates = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/imageCoordinates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getInPlaceMagnifiedImageCoordinates = exports.getLensModeMagnifiedImageCoordinates = void 0;
    var clamp_1 = require_clamp();
    var imageRatio_1 = require_imageRatio();
    function getMinCoordinates(container, largeImage) {
      return {
        x: (largeImage.width - container.width) * -1,
        y: (largeImage.height - container.height) * -1
      };
    }
    function getMaxCoordinates() {
      return {
        x: 0,
        y: 0
      };
    }
    function clampImageCoordinates(imageCoordinates, minCoordinates, maxCoordinates) {
      return {
        x: (0, clamp_1.clamp)(imageCoordinates.x, minCoordinates.x, maxCoordinates.x),
        y: (0, clamp_1.clamp)(imageCoordinates.y, minCoordinates.y, maxCoordinates.y)
      };
    }
    function getCursorPositionAdjustedForLens(position, lensCursorOffset) {
      return {
        x: position.x - lensCursorOffset.x,
        y: position.y - lensCursorOffset.y
      };
    }
    function getLensModeMagnifiedImageCoordinates(containerDimensions, cursorOffset, magnifiedImage, position, image) {
      const adjustedPosition = getCursorPositionAdjustedForLens(position, cursorOffset);
      const ratio = (0, imageRatio_1.getSmallToLargeImageRatio)(image, magnifiedImage);
      const coordinates = {
        x: Math.round(adjustedPosition.x * ratio.x) * -1,
        y: Math.round(adjustedPosition.y * ratio.y) * -1
      };
      const minCoordinates = getMinCoordinates(containerDimensions, magnifiedImage);
      const maxCoordinates = getMaxCoordinates();
      return clampImageCoordinates(coordinates, minCoordinates, maxCoordinates);
    }
    exports.getLensModeMagnifiedImageCoordinates = getLensModeMagnifiedImageCoordinates;
    function getInPlaceMagnifiedImageCoordinates(containerDimensions, magnifiedImage, position) {
      const minCoordinates = getMinCoordinates(containerDimensions, magnifiedImage);
      const maxCoordinates = getMaxCoordinates();
      const ratio = (0, imageRatio_1.getContainerToImageRatio)(containerDimensions, magnifiedImage);
      const coordinates = {
        x: Math.round(position.x * ratio.x) * -1,
        y: Math.round(position.y * ratio.y) * -1
      };
      return clampImageCoordinates(coordinates, minCoordinates, maxCoordinates);
    }
    exports.getInPlaceMagnifiedImageCoordinates = getInPlaceMagnifiedImageCoordinates;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/utils/index.js
var require_utils = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.setSmallImageDimensionState = exports.resolveSmallImage = exports.imageToStrictDimensions = exports.capitalize = exports.styleToCssText = exports.isFluid = exports.isFluidDimension = exports.noop = void 0;
    var fluidCheckRegexp = new RegExp(/(%|vh|vw|vmin|vmax|fit-content|max-content|min-content|auto|stretch|available)$/, "gi");
    function noop2() {
    }
    exports.noop = noop2;
    function isFluidDimension(value) {
      let result = typeof value !== "number";
      result = result && value !== void 0 && fluidCheckRegexp.test(value);
      fluidCheckRegexp.lastIndex = 0;
      return result;
    }
    exports.isFluidDimension = isFluidDimension;
    function isFluid(smallImage) {
      const result = isFluidDimension(smallImage.height) && isFluidDimension(smallImage.width);
      return smallImage.height === void 0 || smallImage.width === void 0 || result;
    }
    exports.isFluid = isFluid;
    function styleToCssText(style) {
      return Object.entries(style).map(([k, v]) => `${k.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`)}:${v}`).join(";");
    }
    exports.styleToCssText = styleToCssText;
    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    exports.capitalize = capitalize;
    function imageToStrictDimensions(imageProps, ref) {
      if (typeof imageProps.height === "number" && typeof imageProps.width === "number") {
        return {
          height: imageProps.height,
          width: imageProps.width
        };
      }
      if (!(ref === null || ref === void 0 ? void 0 : ref.current)) {
        return {
          height: 0,
          width: 0
        };
      }
      return {
        height: ref.current.offsetHeight,
        width: ref.current.offsetWidth
      };
    }
    exports.imageToStrictDimensions = imageToStrictDimensions;
    function resolveSmallImage(smallImageProp, smallImageHeight, smallImageWidth) {
      const smallImage = Object.assign(Object.assign({}, smallImageProp), { height: smallImageHeight || smallImageProp.height || "100%", width: smallImageWidth || smallImageProp.width || "100%" });
      if (!smallImage.onLoad) {
        smallImage.onLoad = noop2;
      }
      return smallImage;
    }
    exports.resolveSmallImage = resolveSmallImage;
    function setSmallImageDimensionState(img, setSmallImage, smallImageProp) {
      if (img) {
        const { naturalHeight, naturalWidth, offsetHeight, offsetWidth } = img;
        const newSmallImage = resolveSmallImage(smallImageProp, isFluidDimension(smallImageProp.height) ? smallImageProp.height : offsetHeight || naturalHeight, isFluidDimension(smallImageProp.width) ? smallImageProp.width : offsetWidth || naturalWidth);
        setSmallImage(newSmallImage);
      }
    }
    exports.setSmallImageDimensionState = setSmallImageDimensionState;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/styles.js
var require_styles = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/styles.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMagnifiedImageStyle = exports.getMagnifiedImageTranslationStyle = exports.getMagnifyContainerStyle = exports.getTransitionActiveStyle = exports.getSmallImageStyle = exports.getContainerStyle = void 0;
    var utils_1 = require_utils();
    function getContainerStyle(smallImage, style, lockedByHintInteraction) {
      const { width, height } = smallImage;
      return Object.assign({ cursor: lockedByHintInteraction ? "default" : "crosshair", position: "relative", height: (0, utils_1.isFluidDimension)(height) ? height : `${height}px`, width: (0, utils_1.isFluidDimension)(width) ? width : `${width}px` }, style);
    }
    exports.getContainerStyle = getContainerStyle;
    function getSmallImageStyle(smallImage, style) {
      const compositSmallImageStyle = Object.assign({ pointerEvents: "none", height: "100%", width: "100%" }, style);
      return compositSmallImageStyle;
    }
    exports.getSmallImageStyle = getSmallImageStyle;
    function getTransitionActiveStyle(isTransitionActive) {
      return {
        opacity: isTransitionActive ? 1 : 0
      };
    }
    exports.getTransitionActiveStyle = getTransitionActiveStyle;
    function getMagnifyContainerStyle(containerDimensions, style, fadeDurationInMs) {
      return Object.assign({ width: containerDimensions.width, height: containerDimensions.height, transition: `opacity ${fadeDurationInMs}ms ease-in`, pointerEvents: "none" }, style);
    }
    exports.getMagnifyContainerStyle = getMagnifyContainerStyle;
    function getMagnifiedImageTranslationStyle(imageCoordinates) {
      const translate = `translate(${imageCoordinates.x}px, ${imageCoordinates.y}px)`;
      return {
        transform: translate,
        WebkitTransform: translate,
        msTransform: translate
      };
    }
    exports.getMagnifiedImageTranslationStyle = getMagnifiedImageTranslationStyle;
    function getMagnifiedImageStyle(magnifiedImage) {
      return Object.assign({ width: magnifiedImage.width, height: magnifiedImage.height, pointerEvents: "none" }, magnifiedImage.style);
    }
    exports.getMagnifiedImageStyle = getMagnifiedImageStyle;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/MaginfyContainer.js
var require_MaginfyContainer = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/MaginfyContainer.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MagnifyContainer = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var imageCoordinates_1 = require_imageCoordinates();
    var utils_1 = require_utils();
    var styles_1 = require_styles();
    var MagnifyContainer = (props) => {
      const { containerDimensions, cursorOffset, fadeDurationInMs = 0, imageComponent: ImageComponent = "img", imageProps, isActive, isLazyLoaded = true, inPlaceMode, isPortalRendered, isPositionOutside, position, sourceImageDimensions, style } = props, rest = __rest(props, ["containerDimensions", "cursorOffset", "fadeDurationInMs", "imageComponent", "imageProps", "isActive", "isLazyLoaded", "inPlaceMode", "isPortalRendered", "isPositionOutside", "position", "sourceImageDimensions", "style"]);
      const timersRef = (0, react_1.useRef)([]);
      const [isTransitionEntering, setIsTransitionEntering] = (0, react_1.useState)(false);
      const [isTransitionActive, setIsTransitionActive] = (0, react_1.useState)(false);
      const [isTransitionLeaving, setIsTransitionLeaving] = (0, react_1.useState)(false);
      const [, setIsTransitionDone] = (0, react_1.useState)(false);
      const isVisible = !isLazyLoaded || isLazyLoaded && (isTransitionEntering || isTransitionActive || isTransitionLeaving);
      const imageCoordinates = inPlaceMode ? (0, imageCoordinates_1.getInPlaceMagnifiedImageCoordinates)(containerDimensions, imageProps, position) : (0, imageCoordinates_1.getLensModeMagnifiedImageCoordinates)(containerDimensions, cursorOffset, imageProps, position, sourceImageDimensions);
      (0, react_1.useEffect)(() => () => {
        var _a;
        return (_a = timersRef.current) === null || _a === void 0 ? void 0 : _a.forEach((timerId) => {
          clearTimeout(timerId);
        });
      }, []);
      (0, react_1.useEffect)(() => {
        if (isActive && !isPositionOutside) {
          setIsTransitionDone(false);
          setIsTransitionEntering(true);
          timersRef.current.push(window.setTimeout(() => {
            setIsTransitionEntering(false);
            setIsTransitionActive(true);
          }, 0));
        } else {
          setIsTransitionLeaving(true);
          setIsTransitionActive(false);
          timersRef.current.push(window.setTimeout(() => {
            setIsTransitionDone(true);
            setIsTransitionLeaving(false);
          }, fadeDurationInMs));
        }
      }, [fadeDurationInMs, isActive, isPositionOutside]);
      const enlargedImageStyle = (0, react_1.useMemo)(() => (0, styles_1.getMagnifiedImageStyle)(imageProps), [imageProps]);
      const computedContainerStyle = Object.assign(Object.assign({ overflow: "hidden" }, (0, styles_1.getMagnifyContainerStyle)(containerDimensions, style, fadeDurationInMs)), (0, styles_1.getTransitionActiveStyle)(isTransitionActive));
      const computedImageStyle = Object.assign(Object.assign({}, enlargedImageStyle), (0, styles_1.getMagnifiedImageTranslationStyle)(imageCoordinates));
      return isVisible ? (0, jsx_runtime_1.jsx)("div", Object.assign({}, rest, { style: computedContainerStyle }, { children: (0, jsx_runtime_1.jsx)(ImageComponent, Object.assign({}, imageProps, { alt: imageProps.alt || "", style: computedImageStyle, onError: imageProps.onError || utils_1.noop, onLoad: imageProps.onLoad || utils_1.noop })) })) : null;
    };
    exports.MagnifyContainer = MagnifyContainer;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/hooks/useLazyRef.js
var require_useLazyRef = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/hooks/useLazyRef.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useLazyRef = void 0;
    var react_1 = require_react();
    var noValue = Symbol("lazyRef.noValue");
    var useLazyRef = (getInitialValue) => {
      const lazyRef = (0, react_1.useRef)(noValue);
      if (lazyRef.current === noValue) {
        lazyRef.current = getInitialValue();
      }
      return lazyRef;
    };
    exports.useLazyRef = useLazyRef;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/constants.js
var require_constants = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MagnifiedImagePosition = exports.DEFAULT_MAGNIFY_CONTAINER_WIDTH = exports.DEFAULT_MAGNIFY_CONTAINER_HEIGHT = exports.INTERACTIONS = exports.UNSET_ACTIVATION_TIMER_NAME = exports.SET_ACTIVATION_TIMER_NAME = exports.MOUSE_EMULATION_GUARD_TIMER_NAME = exports.TAP_GESTURE_TIMER_NAME = exports.PRESS_EVENT_TIMER_NAME = exports.DEFAULT_PORTAL_ID = exports.INPUT_TYPE = void 0;
    exports.INPUT_TYPE = {
      mouse: "mouse",
      touch: "touch"
    };
    exports.DEFAULT_PORTAL_ID = "react-image-magnify-portal";
    exports.PRESS_EVENT_TIMER_NAME = "pressEvent";
    exports.TAP_GESTURE_TIMER_NAME = "tap";
    exports.MOUSE_EMULATION_GUARD_TIMER_NAME = "mouseEmulation";
    exports.SET_ACTIVATION_TIMER_NAME = "setHovering";
    exports.UNSET_ACTIVATION_TIMER_NAME = "unsetHovering";
    exports.INTERACTIONS = {
      touch: "touch",
      tap: "tap",
      press: "press",
      click: "click",
      hover: "hover",
      doubleTap: "double_tap"
    };
    exports.DEFAULT_MAGNIFY_CONTAINER_HEIGHT = "100%";
    exports.DEFAULT_MAGNIFY_CONTAINER_WIDTH = "100%";
    exports.MagnifiedImagePosition = {
      OVER: "over",
      AUTO: "auto",
      "AUTO-START": "auto-start",
      "AUTO-END": "auto-end",
      TOP: "top",
      "TOP-START": "top-start",
      "TOP-END": "top-end",
      BOTTOM: "bottom",
      "BOTTOM-START": "bottom-start",
      "BOTTOM-END": "bottom-end",
      RIGHT: "right",
      "RIGHT-START": "right-start",
      "RIGHT-END": "right-end",
      LEFT: "left",
      "LEFT-START": "left-start",
      "LEFT-END": "left-end"
    };
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/MagnifyContainerPortal.js
var require_MagnifyContainerPortal = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/MagnifyContainerPortal.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MagnifyContainerPortal = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var react_dom_1 = require_react_dom();
    var react_popper_1 = (init_esm(), __toCommonJS(esm_exports));
    var MaginfyContainer_1 = require_MaginfyContainer();
    var useLazyRef_1 = require_useLazyRef();
    var constants_1 = require_constants();
    exports.MagnifyContainerPortal = (0, react_1.forwardRef)((props, ref) => {
      const { portalProps = {} } = props, rest = __rest(props, ["portalProps"]);
      const { className, id, style, placement = constants_1.MagnifiedImagePosition.LEFT, strategy, onFirstUpdate, dataTestId, modifiers = [], horizontalOffset = 0, verticalOffset = 0 } = portalProps;
      const [popperElement, setPopperElement] = (0, react_1.useState)(null);
      const popper = (0, react_popper_1.usePopper)(ref.current, popperElement, {
        placement,
        strategy,
        onFirstUpdate,
        modifiers: [
          {
            name: "offset",
            options: {
              offset: [verticalOffset, horizontalOffset]
            }
          },
          ...modifiers
        ]
      });
      const randId = (0, useLazyRef_1.useLazyRef)(() => Math.floor(Math.random() * 9999));
      const portalRef = (0, useLazyRef_1.useLazyRef)(() => document.createElement("div"));
      const popperRef = (0, react_1.useCallback)((node) => {
        if (node !== null) {
          setPopperElement(node);
        }
      }, []);
      const el = portalRef.current;
      el.id = id || `${constants_1.DEFAULT_PORTAL_ID}-${randId.current}`;
      if (className) {
        el.className = className;
      }
      if (dataTestId) {
        el.setAttribute("data-test-id", dataTestId);
      }
      (0, react_1.useEffect)(() => {
        document.body.appendChild(el);
        return () => {
          document.body.removeChild(el);
        };
      }, []);
      return (0, react_dom_1.createPortal)((0, jsx_runtime_1.jsx)("div", Object.assign({ ref: popperRef, style: Object.assign(Object.assign({ zIndex: 101 }, popper.styles.popper), style) }, popper.attributes.popper, { children: (0, jsx_runtime_1.jsx)(MaginfyContainer_1.MagnifyContainer, Object.assign({ isPortalRendered: true }, rest)) })), el);
    });
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/Lens.js
var require_Lens = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/Lens.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Lens = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var Lens = (props) => {
      const { fadeDurationInMs = 0, isActive, isPositionOutside, style: parentSpecifiedStyle } = props, rest = __rest(props, ["fadeDurationInMs", "isActive", "isPositionOutside", "style"]);
      const defaultStyle = {
        width: "auto",
        height: "auto",
        top: "auto",
        right: "auto",
        bottom: "auto",
        left: "auto",
        display: "block"
      };
      const computedStyle = {
        position: "absolute",
        opacity: isActive && !isPositionOutside ? 1 : 0,
        transition: `opacity ${fadeDurationInMs}ms ease-in`
      };
      const compositStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle), parentSpecifiedStyle), computedStyle);
      return (0, jsx_runtime_1.jsx)("div", Object.assign({ style: compositStyle }, rest));
    };
    exports.Lens = Lens;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensTop.js
var require_LensTop = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensTop.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LensTop = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var clamp_1 = require_clamp();
    var Lens_1 = require_Lens();
    exports.LensTop = (0, react_1.forwardRef)((props, ref) => {
      const { cursorOffset, position, fadeDurationInMs, isActive, isPositionOutside, style: parentSpecifiedStyle } = props, rest = __rest(props, ["cursorOffset", "position", "fadeDurationInMs", "isActive", "isPositionOutside", "style"]);
      const typedRef = ref;
      if (!(typedRef === null || typedRef === void 0 ? void 0 : typedRef.current)) {
        return null;
      }
      const clearLensHeight = cursorOffset.y * 2;
      const maxHeight = typedRef.current.offsetHeight - clearLensHeight;
      const height = (0, clamp_1.clamp)(position.y - cursorOffset.y, 0, maxHeight);
      const computedStyle = {
        height: `${height}px`,
        width: "100%",
        top: "0px"
      };
      return (0, jsx_runtime_1.jsx)(Lens_1.Lens, Object.assign({ fadeDurationInMs, isActive, isPositionOutside, style: Object.assign(Object.assign({}, parentSpecifiedStyle), computedStyle) }, rest));
    });
    exports.LensTop.displayName = "LensTop";
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensLeft.js
var require_LensLeft = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensLeft.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LensLeft = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var clamp_1 = require_clamp();
    var Lens_1 = require_Lens();
    exports.LensLeft = (0, react_1.forwardRef)((props, ref) => {
      const { cursorOffset, position, fadeDurationInMs, isActive, isPositionOutside, style: parentSpecifiedStyle } = props, rest = __rest(props, ["cursorOffset", "position", "fadeDurationInMs", "isActive", "isPositionOutside", "style"]);
      const typedRef = ref;
      if (!(typedRef === null || typedRef === void 0 ? void 0 : typedRef.current)) {
        return null;
      }
      const clearLensHeight = cursorOffset.y * 2;
      const clearLensWidth = cursorOffset.x * 2;
      const maxHeight = typedRef.current.offsetHeight - clearLensHeight;
      const maxWidth = typedRef.current.offsetWidth - clearLensWidth;
      const height = clearLensHeight;
      const width = (0, clamp_1.clamp)(position.x - cursorOffset.x, 0, maxWidth);
      const top = (0, clamp_1.clamp)(position.y - cursorOffset.y, 0, maxHeight);
      const computedStyle = {
        height: `${height}px`,
        width: `${width}px`,
        top: `${top}px`,
        left: "0px"
      };
      return (0, jsx_runtime_1.jsx)(Lens_1.Lens, Object.assign({ fadeDurationInMs, isActive, isPositionOutside, style: Object.assign(Object.assign({}, parentSpecifiedStyle), computedStyle) }, rest));
    });
    exports.LensLeft.displayName = "LensLeft";
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensRight.js
var require_LensRight = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensRight.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LensRight = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var clamp_1 = require_clamp();
    var Lens_1 = require_Lens();
    exports.LensRight = (0, react_1.forwardRef)((props, ref) => {
      const { cursorOffset, position, fadeDurationInMs, isActive, isPositionOutside, style: parentSpecifiedStyle } = props, rest = __rest(props, ["cursorOffset", "position", "fadeDurationInMs", "isActive", "isPositionOutside", "style"]);
      const typedRef = ref;
      if (!(typedRef === null || typedRef === void 0 ? void 0 : typedRef.current)) {
        return null;
      }
      const clearLensHeight = cursorOffset.y * 2;
      const clearLensWidth = cursorOffset.x * 2;
      const maxHeight = typedRef.current.offsetHeight - clearLensHeight;
      const maxWidth = typedRef.current.offsetWidth - clearLensWidth;
      const height = clearLensHeight;
      const width = (0, clamp_1.clamp)(typedRef.current.offsetWidth - position.x - cursorOffset.x, 0, maxWidth);
      const top = (0, clamp_1.clamp)(position.y - cursorOffset.y, 0, maxHeight);
      const computedStyle = {
        height: `${height}px`,
        width: `${width}px`,
        top: `${top}px`,
        right: "0px"
      };
      return (0, jsx_runtime_1.jsx)(Lens_1.Lens, Object.assign({ fadeDurationInMs, isActive, isPositionOutside, style: Object.assign(Object.assign({}, parentSpecifiedStyle), computedStyle) }, rest));
    });
    exports.LensRight.displayName = "LensRight";
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensBottom.js
var require_LensBottom = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/LensBottom.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LensBottom = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var clamp_1 = require_clamp();
    var Lens_1 = require_Lens();
    exports.LensBottom = (0, react_1.forwardRef)((props, ref) => {
      const { cursorOffset, position, fadeDurationInMs, isActive, isPositionOutside, style: parentSpecifiedStyle } = props, rest = __rest(props, ["cursorOffset", "position", "fadeDurationInMs", "isActive", "isPositionOutside", "style"]);
      const typedRef = ref;
      if (!(typedRef === null || typedRef === void 0 ? void 0 : typedRef.current)) {
        return null;
      }
      const clearLensHeight = cursorOffset.y * 2;
      const computedHeight = typedRef.current.offsetHeight - position.y - cursorOffset.y;
      const maxHeight = typedRef.current.offsetHeight - clearLensHeight;
      const height = (0, clamp_1.clamp)(computedHeight, 0, maxHeight);
      const clearLensBottom = position.y + cursorOffset.y;
      const top = Math.max(clearLensBottom, clearLensHeight);
      const computedStyle = {
        height: `${height}px`,
        width: "100%",
        top: `${top}px`
      };
      return (0, jsx_runtime_1.jsx)(Lens_1.Lens, Object.assign({ fadeDurationInMs, isActive, isPositionOutside, style: Object.assign(Object.assign({}, parentSpecifiedStyle), computedStyle) }, rest));
    });
    exports.LensBottom.displayName = "LensBottom";
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/index.js
var require_negative_space = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/negative-space/index.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NegativeSpaceLens = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var LensTop_1 = require_LensTop();
    var LensLeft_1 = require_LensLeft();
    var LensRight_1 = require_LensRight();
    var LensBottom_1 = require_LensBottom();
    exports.NegativeSpaceLens = (0, react_1.forwardRef)((props, ref) => {
      const { cursorOffset, fadeDurationInMs, isActive, isPositionOutside, position, style: userSpecifiedStyle } = props, rest = __rest(props, ["cursorOffset", "fadeDurationInMs", "isActive", "isPositionOutside", "position", "style"]);
      const compositLensStyle = Object.assign({ backgroundColor: "rgba(0,0,0,.4)" }, userSpecifiedStyle);
      return (0, jsx_runtime_1.jsxs)("div", Object.assign({}, rest, { children: [(0, jsx_runtime_1.jsx)(LensTop_1.LensTop, Object.assign({}, props, { ref, style: compositLensStyle })), (0, jsx_runtime_1.jsx)(LensLeft_1.LensLeft, Object.assign({}, props, { ref, style: compositLensStyle })), (0, jsx_runtime_1.jsx)(LensRight_1.LensRight, Object.assign({}, props, { ref, style: compositLensStyle })), (0, jsx_runtime_1.jsx)(LensBottom_1.LensBottom, Object.assign({}, props, { ref, style: compositLensStyle }))] }));
    });
    exports.NegativeSpaceLens.displayName = "NegativeSpaceLens";
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/positive-space/assets/textured-lens-data-uri.js
var require_textured_lens_data_uri = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/positive-space/assets/textured-lens-data-uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dataUri = void 0;
    exports.dataUri = "data:image/gif;base64,R0lGODlhZABkAPABAHOf4fj48yH5BAEAAAEALAAAAABkAGQAAAL+jI+py+0PowOB2oqvznz7Dn5iSI7SiabqWrbj68bwTLL2jUv0Lvf8X8sJhzmg0Yc8mojM5kmZjEKPzqp1MZVqs7Cr98rdisOXr7lJHquz57YwDV8j3XRb/C7v1vcovD8PwicY8VcISDGY2GDIKKf4mNAoKQZZeXg5aQk5yRml+dgZ2vOpKGraQpp4uhqYKsgKi+H6iln7N8sXG4u7p2s7ykvnyxos/DuMWtyGfKq8fAwd5nzGHN067VUtiv2lbV3GDfY9DhQu7p1pXoU+rr5ODk/j7sSePk9Ub33PlN+4jx8v4JJ/RQQa3EDwzcGFiBLi6AfN4UOGCyXegGjIoh0fisQ0rsD4y+NHjgZFqgB5y2Qfks1UPmEZ0OVLlIcKAAA7";
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lens/positive-space/index.js
var require_positive_space = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lens/positive-space/index.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PositiveSpaceLens = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var clamp_1 = require_clamp();
    var textured_lens_data_uri_1 = require_textured_lens_data_uri();
    var react_1 = require_react();
    exports.PositiveSpaceLens = (0, react_1.forwardRef)((props, ref) => {
      const { isActive, isPositionOutside, fadeDurationInMs, cursorOffset: { x: cursorOffsetX, y: cursorOffsetY }, position: { x: positionX, y: positionY }, style: userSpecifiedStyle } = props, rest = __rest(props, ["isActive", "isPositionOutside", "fadeDurationInMs", "cursorOffset", "position", "style"]);
      const typedRef = ref;
      if (!(typedRef === null || typedRef === void 0 ? void 0 : typedRef.current)) {
        return null;
      }
      const defaultStyle = {
        transition: `opacity ${fadeDurationInMs}ms ease-in`,
        backgroundImage: `url(${textured_lens_data_uri_1.dataUri})`
      };
      const width = cursorOffsetX * 2;
      const height = cursorOffsetY * 2;
      const isVisible = isActive && !isPositionOutside;
      const top = positionY - cursorOffsetY;
      const left = positionX - cursorOffsetX;
      const maxTop = typedRef.current.offsetHeight - height;
      const maxLeft = typedRef.current.offsetWidth - width;
      const minOffset = 0;
      const priorityStyle = {
        position: "absolute",
        top: `${(0, clamp_1.clamp)(top, minOffset, maxTop)}px`,
        left: `${(0, clamp_1.clamp)(left, minOffset, maxLeft)}px`,
        width: `${width}px`,
        height: `${height}px`,
        opacity: isVisible ? 1 : 0
      };
      return (0, jsx_runtime_1.jsx)("div", Object.assign({ style: Object.assign(Object.assign(Object.assign({}, defaultStyle), userSpecifiedStyle), priorityStyle) }, rest));
    });
    exports.PositiveSpaceLens.displayName = "PositiveSpaceLens";
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/hint/DefaultHint.js
var require_DefaultHint = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/hint/DefaultHint.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultHint = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    exports.DefaultHint = (0, react_1.memo)((props) => {
      const { isMouseDetected, isTouchDetected, hintTextMouse, hintTextTouch, style } = props, rest = __rest(props, ["isMouseDetected", "isTouchDetected", "hintTextMouse", "hintTextTouch", "style"]);
      return (0, jsx_runtime_1.jsx)("div", Object.assign({ style: Object.assign({ width: "100%", display: "flex", justifyContent: "center", position: "absolute", bottom: "25px", zIndex: 99 }, style) }, rest, { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ style: {
        display: "flex",
        alignItems: "center",
        padding: "5px 10px",
        backgroundColor: "#333",
        borderRadius: "10px",
        opacity: "0.90"
      } }, { children: [(0, jsx_runtime_1.jsx)("img", { alt: "", src: "data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ5MC4yIDQ5MC4yIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0OTAuMiA0OTAuMjsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+CjxnPgoJPGc+CgkJPHBhdGggZD0iTTQxOC41LDQxOC41Yzk1LjYtOTUuNiw5NS42LTI1MS4yLDAtMzQ2LjhzLTI1MS4yLTk1LjYtMzQ2LjgsMHMtOTUuNiwyNTEuMiwwLDM0Ni44UzMyMi45LDUxNC4xLDQxOC41LDQxOC41eiBNODksODkgICAgYzg2LjEtODYuMSwyMjYuMS04Ni4xLDMxMi4yLDBzODYuMSwyMjYuMSwwLDMxMi4ycy0yMjYuMSw4Ni4xLTMxMi4yLDBTMywxNzUuMSw4OSw4OXoiIGZpbGw9IiNGRkZGRkYiLz4KCQk8cGF0aCBkPSJNMjQ1LjEsMzM2LjljMy40LDAsNi40LTEuNCw4LjctMy42YzIuMi0yLjIsMy42LTUuMywzLjYtOC43di02Ny4zaDY3LjNjMy40LDAsNi40LTEuNCw4LjctMy42YzIuMi0yLjIsMy42LTUuMywzLjYtOC43ICAgIGMwLTYuOC01LjUtMTIuMy0xMi4yLTEyLjJoLTY3LjN2LTY3LjNjMC02LjgtNS41LTEyLjMtMTIuMi0xMi4yYy02LjgsMC0xMi4zLDUuNS0xMi4yLDEyLjJ2NjcuM2gtNjcuM2MtNi44LDAtMTIuMyw1LjUtMTIuMiwxMi4yICAgIGMwLDYuOCw1LjUsMTIuMywxMi4yLDEyLjJoNjcuM3Y2Ny4zQzIzMi44LDMzMS40LDIzOC4zLDMzNi45LDI0NS4xLDMzNi45eiIgZmlsbD0iI0ZGRkZGRiIvPgoJPC9nPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+CjxnPgo8L2c+Cjwvc3ZnPgo=", style: {
        width: "25px",
        height: "25px"
      } }), (0, jsx_runtime_1.jsx)("span", Object.assign({ style: {
        padding: "2px 0 0 5px",
        fontFamily: "Arial, sans-serif",
        fontSize: "14px",
        color: "white"
      } }, { children: isTouchDetected ? hintTextTouch : hintTextMouse }))] })) }));
    });
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/lens.js
var require_lens = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/lens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLensCursorOffset = void 0;
    var imageRatio_1 = require_imageRatio();
    function getLensCursorOffsetDimension(value, ratio) {
      return Math.round(value * ratio / 2);
    }
    function getLensCursorOffset(smallImage, largeImage, enlargedImageContainerDimensions) {
      const ratio = (0, imageRatio_1.getLargeToSmallImageRatio)(smallImage, largeImage);
      return {
        x: getLensCursorOffsetDimension(enlargedImageContainerDimensions.width, ratio.x),
        y: getLensCursorOffsetDimension(enlargedImageContainerDimensions.height, ratio.y)
      };
    }
    exports.getLensCursorOffset = getLensCursorOffset;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/dimensions.js
var require_dimensions = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/dimensions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnlargedImageContainerDimension = exports.convertPercentageToDecimal = exports.isPercentageFormat = void 0;
    function isPercentageFormat(val) {
      return typeof val === "string" && /^\d+%$/.test(val);
    }
    exports.isPercentageFormat = isPercentageFormat;
    function convertPercentageToDecimal(percentage, denominator = 100) {
      const denom = typeof denominator === "string" ? parseInt(denominator, 10) : denominator;
      return (typeof percentage === "string" ? parseInt(percentage, 10) : percentage) / denom;
    }
    exports.convertPercentageToDecimal = convertPercentageToDecimal;
    function getEnlargedImageContainerDimension(containerDimension, smallImageDimension, scale, isInPlaceMode) {
      var _a;
      if (isInPlaceMode) {
        return smallImageDimension;
      }
      if (scale) {
        if (scale <= 0 && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) !== "production") {
          console.warn(`[ReactImageMagnify]
                Warning! "scale" cannot be 0 or less (found ${scale}). Defaulting to 0.5.
            `);
          scale = 0.5;
        }
        return (isPercentageFormat(smallImageDimension) ? convertPercentageToDecimal(smallImageDimension) : smallImageDimension) * scale;
      }
      if (isPercentageFormat(containerDimension)) {
        return isPercentageFormat(smallImageDimension) ? convertPercentageToDecimal(smallImageDimension, containerDimension) : smallImageDimension * convertPercentageToDecimal(containerDimension);
      }
      return containerDimension;
    }
    exports.getEnlargedImageContainerDimension = getEnlargedImageContainerDimension;
  }
});

// node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers;
var init_resizeObservers = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js"() {
    resizeObservers = [];
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations;
var init_hasActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js"() {
    init_resizeObservers();
    hasActiveObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.activeTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations;
var init_hasSkippedObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js"() {
    init_resizeObservers();
    hasSkippedObservations = function() {
      return resizeObservers.some(function(ro) {
        return ro.skippedTargets.length > 0;
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg, deliverResizeLoopError;
var init_deliverResizeLoopError = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js"() {
    msg = "ResizeObserver loop completed with undelivered notifications.";
    deliverResizeLoopError = function() {
      var event;
      if (typeof ErrorEvent === "function") {
        event = new ErrorEvent("error", {
          message: msg
        });
      } else {
        event = document.createEvent("Event");
        event.initEvent("error", false, false);
        event.message = msg;
      }
      window.dispatchEvent(event);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
var init_ResizeObserverBoxOptions = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js"() {
    (function(ResizeObserverBoxOptions2) {
      ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
    })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
  }
});

// node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze;
var init_freeze = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/freeze.js"() {
    freeze = function(obj) {
      return Object.freeze(obj);
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize;
var init_ResizeObserverSize = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js"() {
    init_freeze();
    ResizeObserverSize = function() {
      function ResizeObserverSize2(inlineSize, blockSize) {
        this.inlineSize = inlineSize;
        this.blockSize = blockSize;
        freeze(this);
      }
      return ResizeObserverSize2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly;
var init_DOMRectReadOnly = __esm({
  "node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js"() {
    init_freeze();
    DOMRectReadOnly = function() {
      function DOMRectReadOnly2(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.top = this.y;
        this.left = this.x;
        this.bottom = this.top + this.height;
        this.right = this.left + this.width;
        return freeze(this);
      }
      DOMRectReadOnly2.prototype.toJSON = function() {
        var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
        return { x, y, top, right, bottom, left, width, height };
      };
      DOMRectReadOnly2.fromRect = function(rectangle) {
        return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG, isHidden, isElement, isReplacedElement;
var init_element = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/element.js"() {
    isSVG = function(target) {
      return target instanceof SVGElement && "getBBox" in target;
    };
    isHidden = function(target) {
      if (isSVG(target)) {
        var _a = target.getBBox(), width = _a.width, height = _a.height;
        return !width && !height;
      }
      var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
    };
    isElement = function(obj) {
      var _a;
      if (obj instanceof Element) {
        return true;
      }
      var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
      return !!(scope && obj instanceof scope.Element);
    };
    isReplacedElement = function(target) {
      switch (target.tagName) {
        case "INPUT":
          if (target.type !== "image") {
            break;
          }
        case "VIDEO":
        case "AUDIO":
        case "EMBED":
        case "OBJECT":
        case "CANVAS":
        case "IFRAME":
        case "IMG":
          return true;
      }
      return false;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/global.js
var global;
var init_global = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/global.js"() {
    global = typeof window !== "undefined" ? window : {};
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache, scrollRegexp, verticalRegexp, IE, parseDimension, size, zeroBoxes, calculateBoxSizes, calculateBoxSize;
var init_calculateBoxSize = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js"() {
    init_ResizeObserverBoxOptions();
    init_ResizeObserverSize();
    init_DOMRectReadOnly();
    init_element();
    init_freeze();
    init_global();
    cache = /* @__PURE__ */ new WeakMap();
    scrollRegexp = /auto|scroll/;
    verticalRegexp = /^tb|vertical/;
    IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent);
    parseDimension = function(pixel) {
      return parseFloat(pixel || "0");
    };
    size = function(inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) {
        inlineSize = 0;
      }
      if (blockSize === void 0) {
        blockSize = 0;
      }
      if (switchSizes === void 0) {
        switchSizes = false;
      }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
    };
    zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
    });
    calculateBoxSizes = function(target, forceRecalculation) {
      if (forceRecalculation === void 0) {
        forceRecalculation = false;
      }
      if (cache.has(target) && !forceRecalculation) {
        return cache.get(target);
      }
      if (isHidden(target)) {
        cache.set(target, zeroBoxes);
        return zeroBoxes;
      }
      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE && cs.boxSizing === "border-box";
      var switchSizes = verticalRegexp.test(cs.writingMode || "");
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
        devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
        borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
        contentBoxSize: size(contentWidth, contentHeight, switchSizes),
        contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
    };
    calculateBoxSize = function(target, observedBox, forceRecalculation) {
      var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
      switch (observedBox) {
        case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
          return devicePixelContentBoxSize;
        case ResizeObserverBoxOptions.BORDER_BOX:
          return borderBoxSize;
        default:
          return contentBoxSize;
      }
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry;
var init_ResizeObserverEntry = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js"() {
    init_calculateBoxSize();
    init_freeze();
    ResizeObserverEntry = function() {
      function ResizeObserverEntry2(target) {
        var boxes = calculateBoxSizes(target);
        this.target = target;
        this.contentRect = boxes.contentRect;
        this.borderBoxSize = freeze([boxes.borderBoxSize]);
        this.contentBoxSize = freeze([boxes.contentBoxSize]);
        this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode;
var init_calculateDepthForNode = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js"() {
    init_element();
    calculateDepthForNode = function(node) {
      if (isHidden(node)) {
        return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
        depth += 1;
        parent = parent.parentNode;
      }
      return depth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations;
var init_broadcastActiveObservations = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js"() {
    init_resizeObservers();
    init_ResizeObserverEntry();
    init_calculateDepthForNode();
    init_calculateBoxSize();
    broadcastActiveObservations = function() {
      var shallowestDepth = Infinity;
      var callbacks2 = [];
      resizeObservers.forEach(function processObserver(ro) {
        if (ro.activeTargets.length === 0) {
          return;
        }
        var entries = [];
        ro.activeTargets.forEach(function processTarget(ot) {
          var entry = new ResizeObserverEntry(ot.target);
          var targetDepth = calculateDepthForNode(ot.target);
          entries.push(entry);
          ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
          if (targetDepth < shallowestDepth) {
            shallowestDepth = targetDepth;
          }
        });
        callbacks2.push(function resizeObserverCallback() {
          ro.callback.call(ro.observer, entries, ro.observer);
        });
        ro.activeTargets.splice(0, ro.activeTargets.length);
      });
      for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
        var callback = callbacks_1[_i];
        callback();
      }
      return shallowestDepth;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth;
var init_gatherActiveObservationsAtDepth = __esm({
  "node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js"() {
    init_resizeObservers();
    init_calculateDepthForNode();
    gatherActiveObservationsAtDepth = function(depth) {
      resizeObservers.forEach(function processObserver(ro) {
        ro.activeTargets.splice(0, ro.activeTargets.length);
        ro.skippedTargets.splice(0, ro.skippedTargets.length);
        ro.observationTargets.forEach(function processTarget(ot) {
          if (ot.isActive()) {
            if (calculateDepthForNode(ot.target) > depth) {
              ro.activeTargets.push(ot);
            } else {
              ro.skippedTargets.push(ot);
            }
          }
        });
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/process.js
var process2;
var init_process = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/process.js"() {
    init_hasActiveObservations();
    init_hasSkippedObservations();
    init_deliverResizeLoopError();
    init_broadcastActiveObservations();
    init_gatherActiveObservationsAtDepth();
    process2 = function() {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
        depth = broadcastActiveObservations();
        gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
        deliverResizeLoopError();
      }
      return depth > 0;
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger, callbacks, notify, queueMicroTask;
var init_queueMicroTask = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js"() {
    callbacks = [];
    notify = function() {
      return callbacks.splice(0).forEach(function(cb) {
        return cb();
      });
    };
    queueMicroTask = function(callback) {
      if (!trigger) {
        var toggle_1 = 0;
        var el_1 = document.createTextNode("");
        var config = { characterData: true };
        new MutationObserver(function() {
          return notify();
        }).observe(el_1, config);
        trigger = function() {
          el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
        };
      }
      callbacks.push(callback);
      trigger();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver;
var init_queueResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js"() {
    init_queueMicroTask();
    queueResizeObserver = function(cb) {
      queueMicroTask(function ResizeObserver3() {
        requestAnimationFrame(cb);
      });
    };
  }
});

// node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching, isWatching, CATCH_PERIOD, observerConfig, events, time, scheduled, Scheduler, scheduler, updateCount;
var init_scheduler = __esm({
  "node_modules/@juggle/resize-observer/lib/utils/scheduler.js"() {
    init_process();
    init_global();
    init_queueResizeObserver();
    watching = 0;
    isWatching = function() {
      return !!watching;
    };
    CATCH_PERIOD = 250;
    observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
    events = [
      "resize",
      "load",
      "transitionend",
      "animationend",
      "animationstart",
      "animationiteration",
      "keyup",
      "keydown",
      "mouseup",
      "mousedown",
      "mouseover",
      "mouseout",
      "blur",
      "focus"
    ];
    time = function(timeout) {
      if (timeout === void 0) {
        timeout = 0;
      }
      return Date.now() + timeout;
    };
    scheduled = false;
    Scheduler = function() {
      function Scheduler2() {
        var _this = this;
        this.stopped = true;
        this.listener = function() {
          return _this.schedule();
        };
      }
      Scheduler2.prototype.run = function(timeout) {
        var _this = this;
        if (timeout === void 0) {
          timeout = CATCH_PERIOD;
        }
        if (scheduled) {
          return;
        }
        scheduled = true;
        var until = time(timeout);
        queueResizeObserver(function() {
          var elementsHaveResized = false;
          try {
            elementsHaveResized = process2();
          } finally {
            scheduled = false;
            timeout = until - time();
            if (!isWatching()) {
              return;
            }
            if (elementsHaveResized) {
              _this.run(1e3);
            } else if (timeout > 0) {
              _this.run(timeout);
            } else {
              _this.start();
            }
          }
        });
      };
      Scheduler2.prototype.schedule = function() {
        this.stop();
        this.run();
      };
      Scheduler2.prototype.observe = function() {
        var _this = this;
        var cb = function() {
          return _this.observer && _this.observer.observe(document.body, observerConfig);
        };
        document.body ? cb() : global.addEventListener("DOMContentLoaded", cb);
      };
      Scheduler2.prototype.start = function() {
        var _this = this;
        if (this.stopped) {
          this.stopped = false;
          this.observer = new MutationObserver(this.listener);
          this.observe();
          events.forEach(function(name) {
            return global.addEventListener(name, _this.listener, true);
          });
        }
      };
      Scheduler2.prototype.stop = function() {
        var _this = this;
        if (!this.stopped) {
          this.observer && this.observer.disconnect();
          events.forEach(function(name) {
            return global.removeEventListener(name, _this.listener, true);
          });
          this.stopped = true;
        }
      };
      return Scheduler2;
    }();
    scheduler = new Scheduler();
    updateCount = function(n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
    };
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement, ResizeObservation;
var init_ResizeObservation = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObservation.js"() {
    init_ResizeObserverBoxOptions();
    init_calculateBoxSize();
    init_element();
    skipNotifyOnElement = function(target) {
      return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
    };
    ResizeObservation = function() {
      function ResizeObservation2(target, observedBox) {
        this.target = target;
        this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
        this.lastReportedSize = {
          inlineSize: 0,
          blockSize: 0
        };
      }
      ResizeObservation2.prototype.isActive = function() {
        var size2 = calculateBoxSize(this.target, this.observedBox, true);
        if (skipNotifyOnElement(this.target)) {
          this.lastReportedSize = size2;
        }
        if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
          return true;
        }
        return false;
      };
      return ResizeObservation2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail;
var init_ResizeObserverDetail = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js"() {
    ResizeObserverDetail = function() {
      function ResizeObserverDetail2(resizeObserver, callback) {
        this.activeTargets = [];
        this.skippedTargets = [];
        this.observationTargets = [];
        this.observer = resizeObserver;
        this.callback = callback;
      }
      return ResizeObserverDetail2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap, getObservationIndex, ResizeObserverController;
var init_ResizeObserverController = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserverController.js"() {
    init_scheduler();
    init_ResizeObservation();
    init_ResizeObserverDetail();
    init_resizeObservers();
    observerMap = /* @__PURE__ */ new WeakMap();
    getObservationIndex = function(observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
        if (observationTargets[i].target === target) {
          return i;
        }
      }
      return -1;
    };
    ResizeObserverController = function() {
      function ResizeObserverController2() {
      }
      ResizeObserverController2.connect = function(resizeObserver, callback) {
        var detail = new ResizeObserverDetail(resizeObserver, callback);
        observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController2.observe = function(resizeObserver, target, options2) {
        var detail = observerMap.get(resizeObserver);
        var firstObservation = detail.observationTargets.length === 0;
        if (getObservationIndex(detail.observationTargets, target) < 0) {
          firstObservation && resizeObservers.push(detail);
          detail.observationTargets.push(new ResizeObservation(target, options2 && options2.box));
          updateCount(1);
          scheduler.schedule();
        }
      };
      ResizeObserverController2.unobserve = function(resizeObserver, target) {
        var detail = observerMap.get(resizeObserver);
        var index = getObservationIndex(detail.observationTargets, target);
        var lastObservation = detail.observationTargets.length === 1;
        if (index >= 0) {
          lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
          detail.observationTargets.splice(index, 1);
          updateCount(-1);
        }
      };
      ResizeObserverController2.disconnect = function(resizeObserver) {
        var _this = this;
        var detail = observerMap.get(resizeObserver);
        detail.observationTargets.slice().forEach(function(ot) {
          return _this.unobserve(resizeObserver, ot.target);
        });
        detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController2;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver;
var init_ResizeObserver = __esm({
  "node_modules/@juggle/resize-observer/lib/ResizeObserver.js"() {
    init_ResizeObserverController();
    init_element();
    ResizeObserver = function() {
      function ResizeObserver3(callback) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (typeof callback !== "function") {
          throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
        }
        ResizeObserverController.connect(this, callback);
      }
      ResizeObserver3.prototype.observe = function(target, options2) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.observe(this, target, options2);
      };
      ResizeObserver3.prototype.unobserve = function(target) {
        if (arguments.length === 0) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
        }
        if (!isElement(target)) {
          throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
        }
        ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver3.prototype.disconnect = function() {
        ResizeObserverController.disconnect(this);
      };
      ResizeObserver3.toString = function() {
        return "function ResizeObserver () { [polyfill code] }";
      };
      return ResizeObserver3;
    }();
  }
});

// node_modules/@juggle/resize-observer/lib/exports/resize-observer.js
var init_resize_observer = __esm({
  "node_modules/@juggle/resize-observer/lib/exports/resize-observer.js"() {
    init_ResizeObserver();
    init_ResizeObserverEntry();
    init_ResizeObserverSize();
  }
});

// node_modules/@react-hook/passive-layout-effect/dist/module/index.js
var import_react, usePassiveLayoutEffect, module_default;
var init_module = __esm({
  "node_modules/@react-hook/passive-layout-effect/dist/module/index.js"() {
    import_react = __toESM(require_react());
    usePassiveLayoutEffect = import_react.default[typeof document !== "undefined" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"];
    module_default = usePassiveLayoutEffect;
  }
});

// node_modules/@react-hook/latest/dist/module/index.js
var React7, useLatest, module_default2;
var init_module2 = __esm({
  "node_modules/@react-hook/latest/dist/module/index.js"() {
    React7 = __toESM(require_react());
    useLatest = (current) => {
      const storedValue = React7.useRef(current);
      React7.useEffect(() => {
        storedValue.current = current;
      });
      return storedValue;
    };
    module_default2 = useLatest;
  }
});

// node_modules/@react-hook/resize-observer/dist/module/index.js
var module_exports = {};
__export(module_exports, {
  default: () => module_default3
});
function _ref() {
}
function useResizeObserver(target, callback) {
  const resizeObserver = getResizeObserver();
  const storedCallback = module_default2(callback);
  module_default(() => {
    let didUnsubscribe = false;
    const targetEl = target && "current" in target ? target.current : target;
    if (!targetEl)
      return _ref;
    function cb(entry, observer) {
      if (didUnsubscribe)
        return;
      storedCallback.current(entry, observer);
    }
    resizeObserver.subscribe(targetEl, cb);
    return () => {
      didUnsubscribe = true;
      resizeObserver.unsubscribe(targetEl, cb);
    };
  }, [target, resizeObserver, storedCallback]);
  return resizeObserver.observer;
}
function createResizeObserver() {
  let ticking = false;
  let allEntries = [];
  const callbacks2 = /* @__PURE__ */ new Map();
  const observer = new ResizeObserver2((entries, obs) => {
    allEntries = allEntries.concat(entries);
    function _ref2() {
      const triggered = /* @__PURE__ */ new Set();
      for (let i = 0; i < allEntries.length; i++) {
        if (triggered.has(allEntries[i].target))
          continue;
        triggered.add(allEntries[i].target);
        const cbs = callbacks2.get(allEntries[i].target);
        cbs === null || cbs === void 0 ? void 0 : cbs.forEach((cb) => cb(allEntries[i], obs));
      }
      allEntries = [];
      ticking = false;
    }
    if (!ticking) {
      window.requestAnimationFrame(_ref2);
    }
    ticking = true;
  });
  return {
    observer,
    subscribe(target, callback) {
      var _callbacks$get;
      observer.observe(target);
      const cbs = (_callbacks$get = callbacks2.get(target)) !== null && _callbacks$get !== void 0 ? _callbacks$get : [];
      cbs.push(callback);
      callbacks2.set(target, cbs);
    },
    unsubscribe(target, callback) {
      var _callbacks$get2;
      const cbs = (_callbacks$get2 = callbacks2.get(target)) !== null && _callbacks$get2 !== void 0 ? _callbacks$get2 : [];
      if (cbs.length === 1) {
        observer.unobserve(target);
        callbacks2.delete(target);
        return;
      }
      const cbIndex = cbs.indexOf(callback);
      if (cbIndex !== -1)
        cbs.splice(cbIndex, 1);
      callbacks2.set(target, cbs);
    }
  };
}
var ResizeObserver2, _resizeObserver, getResizeObserver, module_default3;
var init_module3 = __esm({
  "node_modules/@react-hook/resize-observer/dist/module/index.js"() {
    init_resize_observer();
    init_module();
    init_module2();
    ResizeObserver2 = typeof window !== "undefined" && "ResizeObserver" in window ? (
      // @ts-ignore
      window.ResizeObserver
    ) : ResizeObserver;
    getResizeObserver = () => !_resizeObserver ? _resizeObserver = createResizeObserver() : _resizeObserver;
    module_default3 = useResizeObserver;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/Activation.js
var require_Activation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/Activation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Activation = void 0;
    var Activation = class {
      constructor(options2) {
        this.onIsActiveChanged = options2.onIsActiveChanged;
        this.isActive = false;
        this.timers = [];
      }
      activate() {
        this.isActive = true;
        this.onIsActiveChanged({ isActive: true });
      }
      deactivate() {
        this.isActive = false;
        this.onIsActiveChanged({ isActive: false });
        this.clearTimers();
      }
      toggleActivation() {
        if (this.isActive) {
          this.deactivate();
        } else {
          this.activate();
        }
      }
      clearTimers() {
        const { timers } = this;
        while (timers.length) {
          const timer = timers.pop();
          if (timer === null || timer === void 0 ? void 0 : timer.id) {
            clearTimeout(timer.id);
          }
        }
      }
      clearTimer(timerName) {
        this.timers.forEach((timer) => {
          if (timer.name === timerName) {
            clearTimeout(timer.id);
          }
        });
      }
    };
    exports.Activation = Activation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/TouchEnvironmentActivation.js
var require_TouchEnvironmentActivation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/TouchEnvironmentActivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TouchEnvironmentActivation = void 0;
    var Activation_1 = require_Activation();
    var TouchEnvironmentActivation = class extends Activation_1.Activation {
      constructor(options2) {
        super(options2);
        this.initialElTop = 0;
        this.currentElTop = 0;
      }
      touchStarted(event) {
        throw new Error("NotYetImplemented");
      }
      touchMoved(event) {
        throw new Error("NotYetImplemented");
      }
      touchEnded() {
        this.deactivate();
      }
      touchCanceled() {
        this.deactivate();
      }
    };
    exports.TouchEnvironmentActivation = TouchEnvironmentActivation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/TouchActivation.js
var require_TouchActivation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/TouchActivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TouchActivation = void 0;
    var TouchEnvironmentActivation_1 = require_TouchEnvironmentActivation();
    var TouchActivation = class extends TouchEnvironmentActivation_1.TouchEnvironmentActivation {
      touchStarted(event) {
        event.e.preventDefault();
        this.activate();
      }
    };
    exports.TouchActivation = TouchActivation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/MouseEnvironmentActivation.js
var require_MouseEnvironmentActivation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/MouseEnvironmentActivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MouseEnvironmentActivation = void 0;
    var Activation_1 = require_Activation();
    var MouseEnvironmentActivation = class extends Activation_1.Activation {
      mouseEntered() {
      }
      mouseMoved() {
      }
      mouseLeft() {
      }
      mouseClicked() {
      }
    };
    exports.MouseEnvironmentActivation = MouseEnvironmentActivation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/HoverActivation.js
var require_HoverActivation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/HoverActivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HoverActivation = void 0;
    var constants_1 = require_constants();
    var MouseEnvironmentActivation_1 = require_MouseEnvironmentActivation();
    var HoverActivation = class extends MouseEnvironmentActivation_1.MouseEnvironmentActivation {
      constructor(options2) {
        super({ onIsActiveChanged: options2.onIsActiveChanged });
        this.hoverDelayInMs = options2.hoverDelayInMs;
        this.hoverOffDelayInMs = options2.hoverOffDelayInMs;
      }
      mouseEntered() {
        this.clearTimers();
        this.schedulActivation(this.hoverDelayInMs);
      }
      mouseLeft() {
        this.clearTimers();
        this.scheduleDeactivation(this.hoverOffDelayInMs);
      }
      schedulActivation(schedule) {
        const scheduleId = setTimeout(() => {
          this.activate();
        }, schedule);
        this.timers.push({
          id: scheduleId,
          name: constants_1.SET_ACTIVATION_TIMER_NAME
        });
      }
      scheduleDeactivation(schedule) {
        const scheduleId = setTimeout(() => {
          this.deactivate();
        }, schedule);
        this.timers.push({
          id: scheduleId,
          name: constants_1.UNSET_ACTIVATION_TIMER_NAME
        });
      }
    };
    exports.HoverActivation = HoverActivation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/ClickActivation.js
var require_ClickActivation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/ClickActivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClickActivation = void 0;
    var MouseEnvironmentActivation_1 = require_MouseEnvironmentActivation();
    var ClickActivation = class extends MouseEnvironmentActivation_1.MouseEnvironmentActivation {
      mouseClicked() {
        this.toggleActivation();
      }
    };
    exports.ClickActivation = ClickActivation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/TapActivation.js
var require_TapActivation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/TapActivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TapActivation = void 0;
    var constants_1 = require_constants();
    var TouchEnvironmentActivation_1 = require_TouchEnvironmentActivation();
    var TapActivation = class extends TouchEnvironmentActivation_1.TouchEnvironmentActivation {
      constructor(options2) {
        super({ onIsActiveChanged: options2.onIsActiveChanged });
        this.hasTapGestureEnded = false;
        this.tapDurationInMs = options2.tapDurationInMs;
        this.tapMoveThreshold = options2.tapMoveThreshold;
      }
      touchStarted(event) {
        this.hasTapGestureEnded = false;
        this.initMoveThreshold(event.position);
        this.setTapEventTimer();
      }
      touchMoved(event) {
        if (this.isActive) {
          return;
        }
        this.setMoveThresholdCriteria(event.position);
      }
      touchEnded() {
        this.hasTapGestureEnded = true;
      }
      get hasPassedMoveThreshold() {
        return Math.abs(this.currentElTop - this.initialElTop) > this.tapMoveThreshold;
      }
      get isTapGestureActive() {
        return !this.hasPassedMoveThreshold && this.hasTapGestureEnded;
      }
      setTapEventTimer() {
        this.timers.push({
          name: constants_1.TAP_GESTURE_TIMER_NAME,
          id: setTimeout(() => {
            if (this.isTapGestureActive) {
              this.toggleActivation();
            }
          }, this.tapDurationInMs)
        });
      }
      setMoveThresholdCriteria(position) {
        this.currentElTop = position.y;
      }
      initMoveThreshold(position) {
        const top = position.y;
        this.initialElTop = top;
        this.currentElTop = top;
      }
    };
    exports.TapActivation = TapActivation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/PressActivation.js
var require_PressActivation = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/PressActivation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PressActivation = void 0;
    var constants_1 = require_constants();
    var TouchEnvironmentActivation_1 = require_TouchEnvironmentActivation();
    var PressActivation = class extends TouchEnvironmentActivation_1.TouchEnvironmentActivation {
      constructor(options2) {
        super({ onIsActiveChanged: options2.onIsActiveChanged });
        this.pressDurationInMs = options2.pressDurationInMs;
        this.pressMoveThreshold = options2.pressMoveThreshold;
      }
      touchStarted(event) {
        this.initPressEventCriteria(event.position);
        this.setPressEventTimer();
      }
      touchMoved(event) {
        if (this.isActive) {
          return;
        }
        this.setPressEventCriteria(event.position);
      }
      setPressEventTimer() {
        this.timers.push({
          name: constants_1.PRESS_EVENT_TIMER_NAME,
          id: setTimeout(() => {
            if (Math.abs(this.currentElTop - this.initialElTop) < this.pressMoveThreshold) {
              this.activate();
            }
          }, this.pressDurationInMs)
        });
      }
      setPressEventCriteria(position) {
        this.currentElTop = position.y;
      }
      initPressEventCriteria(position) {
        const top = position.y;
        this.initialElTop = top;
        this.currentElTop = top;
      }
    };
    exports.PressActivation = PressActivation;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/lib/RelativeCursorPositionObserver.js
var require_RelativeCursorPositionObserver = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/lib/RelativeCursorPositionObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RelativeCursorPositionObserver = void 0;
    var RelativeCursorPositionObserver = class {
      get subject() {
        return this._subject;
      }
      set subject(value) {
        this._subject = value;
      }
      get documentRelativeElementOffset() {
        if (!this._subject) {
          throw new Error("Not yet initialized. Subject is not set");
        }
        if (!this.elementOffset) {
          this.elementOffset = this.getDocumentRelativeElementOffset(this._subject);
        }
        return this.elementOffset;
      }
      getDocumentRelativeElementOffset(el) {
        const rootEl = this.getRootOfEl(el);
        const { left: docLeft, top: docTop } = rootEl.getBoundingClientRect();
        const { left: elLeft, top: elTop } = el.getBoundingClientRect();
        return {
          x: Math.abs(docLeft) + elLeft,
          y: Math.abs(docTop) + elTop
        };
      }
      getRootOfEl(el) {
        if (el.parentElement) {
          return this.getRootOfEl(el.parentElement);
        }
        return el;
      }
      getComputedElementRelativeCursorPosition(event, documentRelativeElementOffset) {
        const position = this.getDocumentRelativeCursorPosition(event);
        const { x: cursorX, y: cursorY } = position;
        const { x: offsetX, y: offsetY } = documentRelativeElementOffset;
        return {
          x: Math.round(cursorX - offsetX),
          y: Math.round(cursorY - offsetY)
        };
      }
      getDocumentRelativeCursorPosition(event) {
        return {
          x: event.pageX,
          y: event.pageY
        };
      }
      getCursorPosition(event) {
        return this.getComputedElementRelativeCursorPosition(event, this.documentRelativeElementOffset);
      }
    };
    exports.RelativeCursorPositionObserver = RelativeCursorPositionObserver;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/CursorPosition.js
var require_CursorPosition = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/CursorPosition.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CursorPosition = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var react_1 = require_react();
    var resize_observer_1 = __importDefault((init_module3(), __toCommonJS(module_exports)));
    var constants_1 = require_constants();
    var utils_1 = require_utils();
    var TouchActivation_1 = require_TouchActivation();
    var HoverActivation_1 = require_HoverActivation();
    var ClickActivation_1 = require_ClickActivation();
    var TapActivation_1 = require_TapActivation();
    var PressActivation_1 = require_PressActivation();
    var RelativeCursorPositionObserver_1 = require_RelativeCursorPositionObserver();
    var getTouchActivationStrategy = (interaction, onIsActiveChanged, pressDurationInMs, pressMoveThreshold, tapDurationInMs, tapMoveThreshold) => {
      const { touch, tap, press } = constants_1.INTERACTIONS;
      switch (interaction) {
        case press:
          return new PressActivation_1.PressActivation({
            onIsActiveChanged,
            pressDurationInMs,
            pressMoveThreshold
          });
        case tap:
          return new TapActivation_1.TapActivation({
            onIsActiveChanged,
            tapDurationInMs,
            tapMoveThreshold
          });
        case touch:
          return new TouchActivation_1.TouchActivation({
            onIsActiveChanged
          });
        default:
          throw new Error("Must implement a touch activation strategy");
      }
    };
    var getMouseActivationStrategy = (interaction, onIsActiveChanged, hoverDelayInMs, hoverOffDelayInMs) => {
      const { hover, click } = constants_1.INTERACTIONS;
      switch (interaction) {
        case hover:
          return new HoverActivation_1.HoverActivation({
            onIsActiveChanged,
            hoverDelayInMs,
            hoverOffDelayInMs
          });
        case click:
          return new ClickActivation_1.ClickActivation({
            onIsActiveChanged
          });
        default:
          throw new Error("Must implement a mouse activation strategy");
      }
    };
    var getElementDimensions = (rect) => {
      const { width, height } = rect;
      return {
        width,
        height
      };
    };
    var getIsPositionOutside = (pos, elementDimensions) => {
      const { x, y } = pos;
      const { width, height } = elementDimensions;
      return x < 0 || y < 0 || x > width || y > height;
    };
    var getTouchEvent = (e) => e.touches[0];
    var CursorPosition = (props) => {
      const { activationInteractionMouse, activationInteractionTouch, children, hoverDelayInMs = 250, hoverOffDelayInMs = 150, isEnabled = true, onActivationChanged = utils_1.noop, onDetectedEnvironmentChanged = utils_1.noop, onOutsideClick, onPositionChanged: onPositionChangedProp = utils_1.noop, pressDurationInMs = 500, pressMoveThreshold = 5, shouldStopTouchMovePropagation = false, style, tabIndex = -1, tapDurationInMs = 180, tapMoveThreshold = 5, useCapture } = props, rest = __rest(props, ["activationInteractionMouse", "activationInteractionTouch", "children", "hoverDelayInMs", "hoverOffDelayInMs", "isEnabled", "onActivationChanged", "onDetectedEnvironmentChanged", "onOutsideClick", "onPositionChanged", "pressDurationInMs", "pressMoveThreshold", "shouldStopTouchMovePropagation", "style", "tabIndex", "tapDurationInMs", "tapMoveThreshold", "useCapture"]);
      const observer = (0, react_1.useRef)(new RelativeCursorPositionObserver_1.RelativeCursorPositionObserver());
      const divRef = (0, react_1.useRef)(null);
      const timersRef = (0, react_1.useRef)([]);
      const [elementDimensions, setElementDimensions] = (0, react_1.useState)({
        width: 0,
        height: 0
      });
      const [shouldGuardAgainstMouseEmulationByDevices, setShouldGuardAgainstMouseEmulationByDevices] = (0, react_1.useState)(false);
      const [isActive, setIsActive] = (0, react_1.useState)(false);
      const [isPositionOutside, setIsPositionOutside] = (0, react_1.useState)(true);
      const [position, setPosition] = (0, react_1.useState)({
        x: 0,
        y: 0
      });
      (0, resize_observer_1.default)(divRef, (entry) => setElementDimensions(getElementDimensions(entry.contentRect)));
      const handleIsActiveChanged = (event) => {
        setIsActive(event.isActive);
      };
      const [touchActivation, setTouchActivation] = (0, react_1.useState)(getTouchActivationStrategy(activationInteractionTouch, handleIsActiveChanged, pressDurationInMs, pressMoveThreshold, tapDurationInMs, tapMoveThreshold));
      const [mouseActivation, setMouseActivation] = (0, react_1.useState)(getMouseActivationStrategy(activationInteractionMouse, handleIsActiveChanged, hoverDelayInMs, hoverOffDelayInMs));
      const unsetShouldGuardAgainstMouseEmulationByDevices = () => {
        timersRef.current.push({
          name: constants_1.MOUSE_EMULATION_GUARD_TIMER_NAME,
          id: setTimeout(() => {
            setShouldGuardAgainstMouseEmulationByDevices(false);
          }, 0)
        });
      };
      const setPositionState = (newPosition) => {
        setIsPositionOutside(getIsPositionOutside(newPosition, elementDimensions));
        setPosition(newPosition);
      };
      const onMouseDetected = () => {
        onDetectedEnvironmentChanged({
          isTouchDetected: false,
          isMouseDetected: true
        });
      };
      const handleTouchStart = (e) => {
        onDetectedEnvironmentChanged({
          isTouchDetected: true,
          isMouseDetected: false
        });
        setShouldGuardAgainstMouseEmulationByDevices(true);
        const newPosition = observer.current.getCursorPosition(getTouchEvent(e));
        setPositionState(newPosition);
        touchActivation.touchStarted({ e, position: newPosition });
      };
      const handleMouseEnter = (e) => {
        if (shouldGuardAgainstMouseEmulationByDevices) {
          return;
        }
        onMouseDetected();
        setPositionState(observer.current.getCursorPosition(e));
        mouseActivation.mouseEntered();
      };
      const handleTouchEnd = () => {
        touchActivation.touchEnded();
        unsetShouldGuardAgainstMouseEmulationByDevices();
      };
      const handleTouchCancel = () => {
        touchActivation.touchCanceled();
        unsetShouldGuardAgainstMouseEmulationByDevices();
      };
      const handleMouseLeave = () => {
        mouseActivation.mouseLeft();
        setIsPositionOutside(true);
      };
      const handleTouchMove = (e) => {
        const newPosition = observer.current.getCursorPosition(getTouchEvent(e));
        touchActivation.touchMoved({ e, position: newPosition });
        if (isActive) {
          setPositionState(newPosition);
          e.preventDefault();
          if (shouldStopTouchMovePropagation) {
            e.stopPropagation();
          }
        }
      };
      const handleMouseMove = (e) => {
        const newPosition = observer.current.getCursorPosition(e);
        setPositionState(newPosition);
      };
      const handleClick = (e) => {
        setPositionState(observer.current.getCursorPosition(e));
        mouseActivation.mouseClicked();
        onMouseDetected();
      };
      const handleKeyDown = (e) => {
        e.preventDefault();
        setIsActive(true);
      };
      const handleKeyUp = (e) => {
        e.preventDefault();
        setIsActive(false);
      };
      const onDocumentMouseClick = (e) => {
        const el = e.target;
        const isDescendantOfRoot = divRef.current && el instanceof Node && divRef.current.contains(el);
        if (!isDescendantOfRoot) {
          onOutsideClick(e);
        }
      };
      const removeEventListeners = () => {
        document.removeEventListener("click", onDocumentMouseClick);
      };
      (0, react_1.useEffect)(() => {
        removeEventListeners();
        if (isEnabled) {
          document.addEventListener("click", onDocumentMouseClick, { capture: useCapture });
        }
        return () => removeEventListeners();
      }, [isEnabled]);
      (0, react_1.useEffect)(() => {
        if (divRef.current) {
          observer.current.subject = divRef.current;
        }
      }, [divRef]);
      (0, react_1.useEffect)(() => {
        onPositionChangedProp({
          isPositionOutside,
          position
        });
        onActivationChanged({ isActive });
      }, [isActive]);
      (0, react_1.useEffect)(() => {
        onPositionChangedProp({
          isPositionOutside,
          position
        });
      }, [isPositionOutside, position]);
      (0, react_1.useEffect)(() => {
        setTouchActivation(getTouchActivationStrategy(activationInteractionTouch, handleIsActiveChanged, pressDurationInMs, pressMoveThreshold, tapDurationInMs, tapMoveThreshold));
        setMouseActivation(getMouseActivationStrategy(activationInteractionMouse, handleIsActiveChanged, hoverDelayInMs, hoverOffDelayInMs));
      }, [
        activationInteractionMouse,
        activationInteractionTouch
      ]);
      return (0, jsx_runtime_1.jsx)("div", Object.assign({ ref: divRef, role: "button", style: Object.assign(Object.assign({}, style), { WebkitUserSelect: "none" }), tabIndex, onClick: isEnabled ? handleClick : void 0, onKeyDown: isEnabled ? handleKeyDown : void 0, onKeyUp: isEnabled ? handleKeyUp : void 0, onMouseEnter: isEnabled ? handleMouseEnter : void 0, onMouseLeave: isEnabled ? handleMouseLeave : void 0, onMouseMove: isEnabled ? handleMouseMove : void 0, onTouchCancel: isEnabled ? handleTouchCancel : void 0, onTouchEnd: isEnabled ? handleTouchEnd : void 0, onTouchMove: isEnabled ? handleTouchMove : void 0, onTouchStart: isEnabled ? handleTouchStart : void 0 }, rest, { children: children({
        isActive,
        isPositionOutside,
        elementDimensions,
        position
      }) }));
    };
    exports.CursorPosition = CursorPosition;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/InPlaceMagnifyContainer.js
var require_InPlaceMagnifyContainer = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/InPlaceMagnifyContainer.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InPlaceMagnifyContainer = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var MaginfyContainer_1 = require_MaginfyContainer();
    var InPlaceMagnifyContainer = (props) => {
      const { style } = props, rest = __rest(props, ["style"]);
      const computedStyle = Object.assign({ position: "absolute", top: "0px", left: "0px", zIndex: 100 }, style);
      return (0, jsx_runtime_1.jsx)(MaginfyContainer_1.MagnifyContainer, Object.assign({ inPlaceMode: true, style: computedStyle }, rest));
    };
    exports.InPlaceMagnifyContainer = InPlaceMagnifyContainer;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/src/ReactImageMagnify.js
var require_ReactImageMagnify = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/src/ReactImageMagnify.js"(exports) {
    "use strict";
    var __rest = exports && exports.__rest || function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReactImageMagnify = void 0;
    var jsx_runtime_1 = require_jsx_runtime();
    var detect_it_1 = (init_detect_it_esm(), __toCommonJS(detect_it_esm_exports));
    var react_1 = require_react();
    var MagnifyContainerPortal_1 = require_MagnifyContainerPortal();
    var negative_space_1 = require_negative_space();
    var positive_space_1 = require_positive_space();
    var DefaultHint_1 = require_DefaultHint();
    var lens_1 = require_lens();
    var dimensions_1 = require_dimensions();
    var CursorPosition_1 = require_CursorPosition();
    var InPlaceMagnifyContainer_1 = require_InPlaceMagnifyContainer();
    var styles_1 = require_styles();
    var utils_1 = require_utils();
    var constants_1 = require_constants();
    var shouldShowHint = (activationInteractionHint) => activationInteractionHint === constants_1.INTERACTIONS.click || activationInteractionHint === constants_1.INTERACTIONS.hover;
    var ReactImageMagnify = (props) => {
      var _a;
      const { activationInteractionHint, activationInteractionMouse = constants_1.INTERACTIONS.hover, activationInteractionTouch = constants_1.INTERACTIONS.press, fadeDurationInMs = 300, hintComponent: HintComponent = DefaultHint_1.DefaultHint, hintProps, isEnabled = true, imageComponent: ImageComponent = "img", imageProps, lensComponent: LensComponentProp, lensProps, magnifyContainerProps, magnifiedImageComponent, magnifiedImageProps, portalProps: portalPropsProp, shouldUsePositiveSpaceLens = false, style } = props, rest = __rest(props, ["activationInteractionHint", "activationInteractionMouse", "activationInteractionTouch", "fadeDurationInMs", "hintComponent", "hintProps", "isEnabled", "imageComponent", "imageProps", "lensComponent", "lensProps", "magnifyContainerProps", "magnifiedImageComponent", "magnifiedImageProps", "portalProps", "shouldUsePositiveSpaceLens", "style"]);
      const { onLoad } = imageProps, usabledImageProps = __rest(imageProps, ["onLoad"]);
      const isZoomClickable = activationInteractionHint === constants_1.INTERACTIONS.click;
      if (activationInteractionHint && activationInteractionMouse === constants_1.INTERACTIONS.click && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.NODE_ENV) !== "production") {
        console.warn(`[ReactImageMagnify]
        Warning! "activationInteractionHint" is set to ${activationInteractionHint} and "activationInteractionMouse" is set to ${constants_1.INTERACTIONS.click}.
        These are incompatible options and may beahve unexpectedly.
        `);
      }
      const imageRef = (0, react_1.useRef)(null);
      const [smallImage, setSmallImage] = (0, react_1.useState)((0, utils_1.resolveSmallImage)(imageProps));
      const [isMouseDetected, setIsMouseDetected] = (0, react_1.useState)(detect_it_1.primaryInput === constants_1.INPUT_TYPE.mouse);
      const [isTouchDetected, setIsTouchDetected] = (0, react_1.useState)(detect_it_1.primaryInput === constants_1.INPUT_TYPE.touch);
      const [imageLoaded, setImageLoaded] = (0, react_1.useState)(false);
      const [lockedByHintInteraction, setLockedByHintInteraction] = (0, react_1.useState)(isZoomClickable);
      const portalProps = Object.assign(Object.assign({}, portalPropsProp), { placement: (portalPropsProp === null || portalPropsProp === void 0 ? void 0 : portalPropsProp.placement) || (isTouchDetected ? constants_1.MagnifiedImagePosition.OVER : constants_1.MagnifiedImagePosition.AUTO) });
      const isInPlaceMode = portalProps.placement === constants_1.MagnifiedImagePosition.OVER;
      const shouldShowLens = !isInPlaceMode && !isTouchDetected;
      const resizeHandler = (0, react_1.useMemo)(() => () => (0, utils_1.setSmallImageDimensionState)(imageRef.current, setSmallImage, imageProps), []);
      const computedEnlargedImageContainerDimensions = (0, react_1.useMemo)(() => {
        var _a2, _b;
        return {
          width: (0, dimensions_1.getEnlargedImageContainerDimension)((magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.width) || constants_1.DEFAULT_MAGNIFY_CONTAINER_WIDTH, ((_a2 = imageRef === null || imageRef === void 0 ? void 0 : imageRef.current) === null || _a2 === void 0 ? void 0 : _a2.offsetWidth) || smallImage.width || constants_1.DEFAULT_MAGNIFY_CONTAINER_WIDTH, magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.scale, isInPlaceMode),
          height: (0, dimensions_1.getEnlargedImageContainerDimension)((magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.height) || constants_1.DEFAULT_MAGNIFY_CONTAINER_HEIGHT, ((_b = imageRef === null || imageRef === void 0 ? void 0 : imageRef.current) === null || _b === void 0 ? void 0 : _b.offsetHeight) || smallImage.height || constants_1.DEFAULT_MAGNIFY_CONTAINER_HEIGHT, magnifyContainerProps === null || magnifyContainerProps === void 0 ? void 0 : magnifyContainerProps.scale, isInPlaceMode)
        };
      }, [magnifyContainerProps, smallImage, isInPlaceMode]);
      const cursorOffset = (0, react_1.useMemo)(() => (0, lens_1.getLensCursorOffset)((0, utils_1.imageToStrictDimensions)(smallImage, imageRef), magnifiedImageProps, computedEnlargedImageContainerDimensions), [computedEnlargedImageContainerDimensions, magnifiedImageProps, smallImage]);
      (0, react_1.useEffect)(() => {
        setSmallImage((0, utils_1.resolveSmallImage)(imageProps));
      }, [imageProps]);
      (0, react_1.useEffect)(() => {
        setLockedByHintInteraction(activationInteractionHint === constants_1.INTERACTIONS.click);
      }, [activationInteractionHint]);
      (0, react_1.useEffect)(() => {
        if (!(0, utils_1.isFluid)(imageProps)) {
          (0, utils_1.setSmallImageDimensionState)(imageRef.current, setSmallImage, imageProps);
          window.addEventListener("resize", resizeHandler);
        } else {
          window.removeEventListener("resize", resizeHandler);
        }
        return () => window.removeEventListener("resize", resizeHandler);
      }, [imageProps, imageRef]);
      const generateHintStyle = (hintPropsStyle) => {
        const hintStyle = Object.assign({}, hintPropsStyle);
        if (lockedByHintInteraction) {
          hintStyle.cursor = "pointer";
        }
        return hintStyle;
      };
      const handleDetectedEnvironmentChanged = (detectedInputType) => {
        setIsMouseDetected(detectedInputType.isMouseDetected);
        setIsTouchDetected(detectedInputType.isTouchDetected);
      };
      const handleHintClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setLockedByHintInteraction(false);
      };
      const handleHintTouchEnd = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setLockedByHintInteraction(false);
      };
      const handleOutsideClick = () => {
        if (isZoomClickable) {
          setLockedByHintInteraction(true);
        }
      };
      const onImageComplete = () => {
        if (!(0, utils_1.isFluid)(imageProps)) {
          (0, utils_1.setSmallImageDimensionState)(imageRef.current, setSmallImage, imageProps);
        }
        setImageLoaded(true);
      };
      const handleImageLoadOrComplete = (e) => {
        if (!imageLoaded) {
          if (smallImage.onLoad) {
            smallImage.onLoad(e);
          }
          onImageComplete();
        }
      };
      const HintComponentOrNull = activationInteractionHint && shouldShowHint(activationInteractionHint) ? (0, jsx_runtime_1.jsx)(HintComponent, Object.assign({}, hintProps, { hintTextMouse: (hintProps === null || hintProps === void 0 ? void 0 : hintProps.hintTextMouse) || `${(0, utils_1.capitalize)(activationInteractionHint)} to Zoom`, hintTextTouch: (hintProps === null || hintProps === void 0 ? void 0 : hintProps.hintTextTouch) || "Long-Touch to Zoom", isMouseDetected, isTouchDetected, style: generateHintStyle(hintProps === null || hintProps === void 0 ? void 0 : hintProps.style), onClick: lockedByHintInteraction ? handleHintClick : void 0, onTouchEnd: lockedByHintInteraction ? handleHintTouchEnd : void 0 })) : null;
      const LensComponent = LensComponentProp || shouldUsePositiveSpaceLens ? positive_space_1.PositiveSpaceLens : negative_space_1.NegativeSpaceLens;
      (0, react_1.useLayoutEffect)(() => {
        var _a2;
        if ((_a2 = imageRef.current) === null || _a2 === void 0 ? void 0 : _a2.complete) {
          onImageComplete();
        }
      }, []);
      (0, react_1.useEffect)(() => {
        if (imageRef.current) {
          imageRef.current.onload = handleImageLoadOrComplete;
        }
      }, []);
      return (0, jsx_runtime_1.jsx)(CursorPosition_1.CursorPosition, Object.assign({ shouldStopTouchMovePropagation: true, activationInteractionMouse, activationInteractionTouch, isEnabled, style: (0, styles_1.getContainerStyle)(smallImage, style, lockedByHintInteraction), onDetectedEnvironmentChanged: handleDetectedEnvironmentChanged, onOutsideClick: handleOutsideClick }, rest, { children: ({ position, isActive, isPositionOutside }) => (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(ImageComponent, Object.assign({}, usabledImageProps, { alt: smallImage.alt, ref: imageRef, style: (0, styles_1.getSmallImageStyle)(smallImage, imageProps.style) })), imageLoaded && (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [HintComponentOrNull, shouldShowLens && !lockedByHintInteraction && (0, jsx_runtime_1.jsx)(LensComponent, Object.assign({ cursorOffset, fadeDurationInMs, isActive, isPositionOutside, position }, lensProps, { ref: imageRef })), isInPlaceMode && !lockedByHintInteraction && (0, jsx_runtime_1.jsx)(InPlaceMagnifyContainer_1.InPlaceMagnifyContainer, Object.assign({ containerDimensions: computedEnlargedImageContainerDimensions, cursorOffset, fadeDurationInMs, imageComponent: magnifiedImageComponent, imageProps: magnifiedImageProps, isActive, isPositionOutside, position, sourceImageDimensions: (0, utils_1.imageToStrictDimensions)(smallImage, imageRef) }, magnifyContainerProps)), !isInPlaceMode && !lockedByHintInteraction && (0, jsx_runtime_1.jsx)(MagnifyContainerPortal_1.MagnifyContainerPortal, Object.assign({ containerDimensions: computedEnlargedImageContainerDimensions, cursorOffset, fadeDurationInMs, imageComponent: magnifiedImageComponent, imageProps: magnifiedImageProps, isActive, isPositionOutside, portalProps, position, sourceImageDimensions: (0, utils_1.imageToStrictDimensions)(smallImage, imageRef) }, magnifyContainerProps, { ref: imageRef }))] })] }) }));
    };
    exports.ReactImageMagnify = ReactImageMagnify;
  }
});

// node_modules/@blacklab/react-image-magnify/dist/index.js
var require_dist = __commonJS({
  "node_modules/@blacklab/react-image-magnify/dist/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var ReactImageMagnify_1 = require_ReactImageMagnify();
    exports.default = ReactImageMagnify_1.ReactImageMagnify;
  }
});
export default require_dist();
//# sourceMappingURL=@blacklab_react-image-magnify.js.map
